### 场景管理

* BVH（包围体层次结构）
* BSP树
  * 轴对齐
    * 创建树：将整个场景包围在一个AABB中，选取xyz其中一个轴，生成一个与之垂直的平面，将该AABB分为两个小AABB，然后以递归的方式继续对生成的AABB进行分割，直到树达到最大深度或AABB中包含的几何图元数量低于用户定义的某个阈值
    * 物体与分割平面相交处理方法
      * 存储在分割平面所在的节点中
        * 效率比较低，比如物体比较小，但是恰好被平面分割，不得不将其存在较高的节点中，所以实际中很少采用这种做法
      * 储存在多个叶子节点
        * 会导致相同的物体被绘制多次，一般使用timestamping方法对其进行改进，即对绘制过的几何体做一个标记，绘制前对这个标记进行检查，若已经绘制过，则不再绘制，这种方法使用的比较多
      * 将这个物体由平面分为两个物体
        * 要对图元进行分割，所以计算量比较大，而且对于动态物体的渲染不太方便
    * 分割平面的选取
      * 按照xyz-xyz……的顺序进行循环分割，如果每次都选择中间位置，则结果和八叉树一样，BSP树相对于八叉树的优势之一就是平面的位置可以随意选择
      * 对AABB的最长边进行分割
      * 通过相关算法（geometric probablity theory）计算出近似最优的分割平面，该分割平面将尽可能少的与几何体相交
  * 多边形对齐
    * 创建树
      * 在根节点处选取一个多边形，用这个多边形所在平面将场景中剩余的多边形分为两组，对于与分割平面相交的多边形，沿着相交线将这个多边形分为两个部分。接下来采用同样的方式对这些多边形进行递归分割，直到所有的多边形都在这棵BSP树中
    * 多边形对齐BSP树的创建非常耗时，适合静态场景
* 四叉树
* 八叉树
  * 创建树
    * 八叉树类似轴对齐BSP树。沿着轴对齐包围盒的三条轴对其进行分割，分割点必须位于包围盒的中心点，以这种方式生成8个新的包围盒。八叉树通过将整个场景包含在一个最小的轴对齐包围盒中进行构造，递归分割，直到达到最大递归层次或包围盒中包含的图元小于某个阈值
* 模糊K-D树

[返回目录](https://hehanxin.github.io/TA/index)